@import "globals.cocoascript";
@import 'MochaJSDelegate.js'

var onRun = function(context) {
    var sketch = context.api();
    var app = [NSApplication sharedApplication];
    var layers = sketch.selectedDocument.selectedLayers;
    //var filepath = "/Users/Young/Documents/pixelcode/app/tests/";
    var filepath = globals.filepath;
    //var data = request("http://localhost:3000/test")
    //log(JSON.parse(data))
    log("begins here:");
    for (var key in context.document) {
        if (Object.prototype.hasOwnProperty.call(context.document, key)) {
            log(key);
            var val = context.document[key];
            log(val);
            // use val
        }
    }

    var window_ = createWindow();
    var webView = createWebView(context, window_);
    // createWebViewRedirectDelegate(context, webView);
    createWebViewChangeLocationDelegate(context, webView);

    [NSApp run];

    // if (layers.isEmpty) {
    //     context.document.showMessage("PixelCode: No artboard selected.");
    // }
    // else {
    //     layers.iterate(function(layer) {
    //         if (layer.isArtboard) {
    //             output = exportJSON(layer, filepath);
    //
    //             var options = {
    //                 "scales" : "1",
    //                 "formats" : "svg",
    //                 "overwriting" : "true",
    //                 "output": filepath
    //             };
    //             layer.export(options);
    //             layer.iterate(function(currentLayer) {
    //                 renameLayers(currentLayer, output["originalNames"]);
    //             });
    //             context.document.showMessage("Pixelcode: Export finished!");
    //         } else {
    //             context.document.showMessage("Pixelcode: No artboard selected.");
    //         }
    //     });
    // };
};

/**
 * Create Webview Redirect Delegate
 *
 * Creates a Cocoa delegate class, then registers a callback for the redirection event.
 */
function createWebViewRedirectDelegate(context, webView) {
    /**
     * Create a Delegate class and register it
     */
    var className = 'MochaJSDelegate_DynamicClass_SymbolUI_WebviewRedirectDelegate' + NSUUID.UUID().UUIDString();
    var delegateClassDesc = MOClassDescription.allocateDescriptionForClassWithName_superclass_(className, NSObject);
    delegateClassDesc.registerClass();

    /**
     * Register the "event" to respond to and specify the callback function
     */
    var redirectEventSelector = NSSelectorFromString('webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:');
    delegateClassDesc.addInstanceMethodWithSelector_function_(
      // The "event" - the WebView is about to redirect soon
      NSSelectorFromString('webView:willPerformClientRedirectToURL:delay:fireDate:forFrame:'),

      // The "listener" - a callback function to fire
      function(sender, URL) {
        // Ensure its the URL we want to respond to.
        // You can also fire different methods based on the URL if you have multiple events.
        if ('https://localhost:8080/symbolexport' != URL) {
          return;
        }
        // A special method to export symbols - we haven't created it yet
        context.document.showMessage("Exported symbols!");
      }
    );

    // Associate the new delegate to the WebView we already created
    webView.setFrameLoadDelegate_(
      NSClassFromString(className).new()
    );

};

function createWebViewChangeLocationDelegate(context, webView) {
    /**
     * Create a Delegate class and register it
     */
    var className = 'MochaJSDelegate_DynamicClass_SymbolUI_WebviewRedirectDelegate' + NSUUID.UUID().UUIDString();
    var delegateClassDesc = MOClassDescription.allocateDescriptionForClassWithName_superclass_(className, NSObject);
    delegateClassDesc.registerClass();

    /**
     * Register the "event" to respond to and specify the callback function
     */
    var windowObject = webView.windowScriptObject();
    var changeLocationEventSelector = NSSelectorFromString('webView:didChangeLocationWithinPageForFrame:');
    delegateClassDesc.addInstanceMethodWithSelector_function_(
      // The "event" - the WebView is about to redirect soon
      NSSelectorFromString('webView:didChangeLocationWithinPageForFrame:'),

      // The "listener" - a callback function to fire
      function(webView, webFrame) {
        var locationHash = windowObject.evaluateWebScript("window.location.hash");
        //The hash object exposes commands and parameters
        //In example, if you send updateHash('add','artboardName','Mark')
        //Youâ€™ll be able to use hash.artboardName to return 'Mark'
        var hash = parseHash(locationHash);
        log(hash);
      }
    );

    // Associate the new delegate to the WebView we already created
    webView.setFrameLoadDelegate_(
      NSClassFromString(className).new()
    );

};


function createWindow() {
  var window_ = [[[NSWindow alloc]
      initWithContentRect:NSMakeRect(0, 0, 1200, 600)
      styleMask:NSTitledWindowMask | NSClosableWindowMask
      backing:NSBackingStoreBuffered
      defer:false
    ] autorelease];
  window_.center();
  window_.makeKeyAndOrderFront_(window_);
  return window_;
}

function createWebView(context, window_) {
  // create frame for loading content in
  var webviewFrame = NSMakeRect(0, 0, 1200, 600);

  // Request index.html
  var webviewFolder   = "/Users/kevinchan/Documents/pixelcode/plugin/pixelcode.sketchplugin/Contents/Sketch"+ '/webview/';
  var webviewHtmlFile = webviewFolder + 'index.html';
  log(webviewHtmlFile);
  var requestUrl      = [NSURL fileURLWithPath:webviewHtmlFile];
  var urlRequest      = [NSMutableURLRequest requestWithURL:requestUrl];

  // Create the WebView, frame, and set content
  var webView = WebView.new();
  webView.initWithFrame(webviewFrame);
  webView.mainFrame().loadRequest(urlRequest);
  window_.contentView().addSubview(webView);

  return webView;
}

function parseHash(aURL) {
  aURL = aURL;
  var vars = {};
  var hashes = aURL.slice(aURL.indexOf('#') + 1).split('&');

    for(var i = 0; i < hashes.length; i++) {
       var hash = hashes[i].split('=');

       if(hash.length > 1) {
         vars[hash[0].toString()] = hash[1];
       } else {
        vars[hash[0].toString()] = null;
       }
    }

    return vars;
}


function request(queryURL) {
   var request = NSMutableURLRequest.new();
   [request setHTTPMethod:@"POST"];
   [request setURL:[NSURL URLWithString:queryURL]];

   var session = NSURLSession.sharedSession();
   var task = session.dataTaskWithRequest(request);
   task.resume()

   var error = NSError.new();
   var responseCode = null;

   var oResponseData = [NSURLConnection sendSynchronousRequest:request returningResponse:responseCode error:error];

   var dataString = [[NSString alloc] initWithData:oResponseData encoding:NSUTF8StringEncoding];

   return dataString;
}

function renameLayers(layer, originalNames) {
  layer.name = originalNames[layer.id];
  if (layer.isGroup) {
    layer.iterate(function(subLayer) {
      renameLayers(subLayer, originalNames);
    });
  }
}

function exportJSON(artboard, filepath){
    var layerArray = [];
    var ret = { "layerNames": [], "dictList": [] , "originalNames": {} };

    artboard.iterate(function(layer) {
        if (layer.isImage) {
            var options = {
                "scales" : "1",
                "formats" : "png",
                "overwriting" : "true",
                "output": filepath
            };
            layer.export(options);
        }

        output = checkFormatting(layer, ret["layerNames"], ret["originalNames"]);
        ret = output;

        for (var i = 0; i < ret["dictList"].length; i++) {
            layerArray.push(ret["dictList"][i]);
        }
    });

    // Create JSON and save to file
    artboardName = artboard.name;
    var jsonObj = { layers : layerArray };
    var file = NSString.stringWithString(JSON.stringify(jsonObj, null, "\t"));
    [file writeToFile:filepath+artboardName+".json" atomically:true encoding:NSUTF8StringEncoding error:null];
    return ret;
}

// Account for sublayers in checking formatting
function checkFormatting(layer, layerNames, originalNames) {
    var ret = {"layerNames": layerNames, "dictList": [],
               "originalNames": originalNames};
    var stack = [layer];

    while (stack.length >= 1) {
        var currentLayer = stack.pop();
        var originalName = String(currentLayer.name);
        ret["originalNames"][currentLayer.id] = originalName;

        layerName = String(currentLayer.name.replace(/\s+/, ""));
        layerName = lowerCaseFirstChar(layerName);

        if (arrayContains(layerName, ret["layerNames"])) {
          var name = layerName;
          var counter = 1;
          while (arrayContains(name, ret["layerNames"])) {
            name = layerName + counter;
            counter++;
          }
          layerName = name;
        }

        currentLayer.name = layerName;

        var currentDict = {};
        currentDict["originalName"] = originalName;
        currentDict["name"] = layerName;
        currentDict["x"] = String(currentLayer.frame.x);
        currentDict["y"] = String(currentLayer.frame.y);
        currentDict["height"] = String(currentLayer.frame.height);
        currentDict["width"] = String(currentLayer.frame.width);
        if (currentLayer.isText) currentDict["text_align"] = String(currentLayer.alignment);

        if (currentLayer.container.isArtboard) {
          currentDict["abs_x"] = currentDict["x"];
          currentDict["abs_y"] = currentDict["y"];
        } else {
          var absx = String(currentLayer.frame.x + currentLayer.container.frame.x);
          var absy = String(currentLayer.frame.y + currentLayer.container.frame.y);
          currentDict["abs_x"] = absx;
          currentDict["abs_y"] = absy;
        }

        ret["layerNames"].push(layerName);
        ret["dictList"].push(currentDict);

        if (currentLayer.isGroup) {
            currentLayer.iterate(function(subLayer) {
                stack.push(subLayer);
            });
        }
    }
    return ret;
}

function hasWhiteSpace(s) {
    return s.indexOf(' ') >= 0;
}

function arrayContains(needle, arrhaystack) {
    return (arrhaystack.indexOf(needle) > -1);
}

function lowerCaseFirstChar(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}
